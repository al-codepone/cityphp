<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Database System</title>
        <meta name="description" content=""/>
        <meta charset="utf-8"/>
        <link type="text/css" rel="stylesheet" href="styles.css"/>
    </head>
    <body>
        <a href="index.html">< Home</a>
        <h2>Database System</h2>
        <p>Here we discuss the cityphp database system. The database system supports most PHP RDBMS vendors including MySQL and PostgreSQL. When you use the database system you must write all the raw vendor specific SQL. The database system is based on two abstract classes: DatabaseHandle and DatabaseAdapter. DatabaseHandle abstracts away the different database vendor extensions to a common set of public methods. DatabaseAdapter wraps a DatabaseHandle object. Both of these classes are in /cityphp/database/. The source code for the examples in this section is available in the sample_applications directory as examples one, two and three.</p>
        <p>Let's summarize what we are going to cover in this section. First we are going to learn all the DatabaseHandle concepts. After going over the DatabaseHandle concepts, we will build three example database applications. All three example applications do the same thing but each uses a different database abstraction layer. The first application demonstrates the basics of how to use DatabaseHandle via a simple MySqlDatabaseHandle example. The remaining two example applications demonstrate how to use the database API architecture; we will introduce database API below when we get to it. The first database API example shows you how to implement database API using a single type of DatabaseHandle; for our example we use PostgreSqlDatabaseHandle. The second database API example will show you how to support multiple database vendors per application; in this case we will use DatabaseAdapter, MySqlDatabaseHandle and PostgreSqlDatabaseHandle. We explain DatabaseAdapter below when we use it.</p>
        <p>First we are going to list the key concepts of the abstract DatabaseHandle class. The first thing to realize about DatabaseHandle is that there will be a class for each database vendor that extends DatabaseHandle. For example there is a MySqlDatabaseHandle and a PostgreSqlDatabaseHandle. DatabaseHandle implements a public getConn() method and a public databaseError() method. The getConn() method returns the low level vendor specific database connection if you need it. The databaseError() method simply calls die(errorMessage). DatabaseHandle also has three abstract public methods: readQuery(), writeQuery() and escapeString(). The next couple of paragraphs cover the DatabaseHandle concepts in more detail.</p>
	    <p>We need to talk about our DatabaseHandle child class constructors. Each DatabaseHandle child class constructor takes the same parameters as the respective database vendor connection function or method plus one additional errorMessage parameter at the end. For example, the MySqlDatabaseHandle constructor takes the same first six parameters as the mysqli_connect() function plus the errorMessage parameter at the end. Another example, the PostgreSqlDatabaseHandle constructor takes the same first two parameters as the pg_connect() function plus the errorMessage parameter at the end.</p>
        <p>Now let's address the three abstract methods defined in DatabaseHandle. Again they are readQuery(), writeQuery() and escapeString(). Each of these methods must be implemented in each vendor specific DatabaseHandle child class using vendor specific functions or methods. readQuery() is for queries like SELECT, SHOW, DESCRIBE and EXPLAIN that return result sets. readQuery() will always return an array of associative arrays. writeQuery() is for all queries that don't return a result set like CREATE TABLE, INSERT, UPDATE and DELETE. escapeString() is for escaping strings you use in queries.</p>
        <p>The last concept we discuss for DatabaseHandle is the errorMessage. As mentioned, the last parameter of each DatabaseHandle child class constructor is the errorMessage. The default errorMessage is always 'database error'. When you use readQuery() and writeQuery(), databaseError() is automatically called for you if there is a database error. On the other hand, if you use getConn() to call a vendor specific function or method and bypass readQuery() and writeQuery() then you need to make calls to databaseError() yourself where appropriate. It is very important that your errorMessage be compatible with the type of document you are rendering. For example, if you are using a DatabaseHandle object that is involved in rendering a JSON document then your errorMessage should be a chunk of JSON. If you are rendering an HTML document then your errorMessage should be a chunk of HTML.</p>
        <p>Now that we've covered all the DatabaseHandle concepts let's see an example of how to use DatabaseHandle. This example uses MySqlDatabaseHandle. For this example we are going to instantiate a MySqlDatabaseHandle object, create a table, insert some rows and then select the rows and print them out. For this example we only need a constants.php and an index.php. Here is the constants.php:</p>
        <pre>&lt;?php

define('CITY_PHP', '/somedir/cityphp/');
define('TABLE_WORDS', 'words');

define('MYSQL_DATABASE_HOST', 'host');
define('MYSQL_DATABASE_USERNAME', 'username');
define('MYSQL_DATABASE_PASSWORD', 'password');
define('MYSQL_DATABASE_NAME', 'databaseName');

?&gt;</pre>
        <p>And here is the index.php:</p>
        <pre>&lt;?php

require_once('./constants.php');
require_once(CITY_PHP . 'database/MySqlDatabaseHandle.php');

$words = array('123',
    "'green'",
    '"dog"',
    '&&gt;&lt;\/"');

$databaseHandle = new MySqlDatabaseHandle(MYSQL_DATABASE_HOST,
    MYSQL_DATABASE_USERNAME,
    MYSQL_DATABASE_PASSWORD,
    MYSQL_DATABASE_NAME);

$query = sprintf('CREATE TABLE %s (
    word_id TINYINT AUTO_INCREMENT NOT NULL PRIMARY KEY,
    word VARCHAR(64))',
    TABLE_WORDS);

$databaseHandle-&gt;writeQuery($query);

$query = sprintf('INSERT INTO %s
    (word_id, word) VALUES',
    TABLE_WORDS);

foreach($words as $i =&gt; $word) {
    $query .= $i &gt; 0 ? ',' : '';
    $query .= sprintf('(NULL, "%s")',
        $databaseHandle-&gt;escapeString($word));
}

$databaseHandle-&gt;writeQuery($query);

$query = sprintf('SELECT word_id, word FROM %s', TABLE_WORDS);
foreach($databaseHandle-&gt;readQuery($query) as $row) {
    printf('%s=%s ', $row['word_id'], htmlspecialchars($row['word']));
}

?&gt;</pre>
        <p>The output is:</p>
        <pre>1=123 2='green' 3="dog" 4=&&gt;&lt;\/"</pre>
        <p>The above source code only serves as an introduction to DatabaseHandle and should not be used in web applications; try one of the database API architectures below for your database abstraction layer. We can still learn how DatabaseHandle works by examining the above code.  As you can see constants.php has the required CITY_PHP constant, a constant for the words table and there are also database credential constants. Then starting in index.php we require_once() constants.php and MySqlDatabaseHandle.php. Then we setup a words array. Next we establish a database connection by instantiating a MySqlDatabaseHandle object. Notice that when we instantiate the MySqlDatabaseHandle object it takes the same parameters as mysqli_connect(). Next we build a CREATE TABLE query string using sprintf() and execute the query using writeQuery(). After that we build an INSERT query string and execute it using writeQuery(). Notice how we are using escapeString() to incorporate the words from the words array into the INSERT query. If you have user submitted data that needs to be used in a query for readQuery() or writeQuery(), then you should use escapeString(). We then build a SELECT query string using sprintf(). Finally we execute the SELECT query using readQuery() and we print the returned rows to the browser using printf().</p>
        <p>Now let's move on to the first database API example. Before we describe database API it's important to realize that the cityphp database system is a set of building blocks that can implement different database abstraction layers besides the database API architecture. However, the only database abstraction layer we outline in this section is the database API architecture. The database API architecture is simple: define a set of public methods on a single object and then use those public methods to interact with the database. For our first database API example we need to write four files: constants.php, IDatabaseApi.php, DatabaseApi.php and index.php. Here's constants.php:</p>
        <pre>&lt;?php

define('CITY_PHP', '/somedir/cityphp/');
define('EXAMPLE2_PHP', '/somedir/example2php/');

define('PGSQL_DATABASE_CONNECTION_STRING', 'dbname=myDatabaseName
    user=myUsername
    password=myPassword');

?&gt;</pre>
        <p>IDatabaseApi.php:</p>
        <pre>&lt;?php

interface IDatabaseApi {
    const TABLE_WORDS = 'words';

    public function install();
    public function selectWords();
    public function insertWords(array $words);
}

?&gt;</pre>
        <p>DatabaseApi.php:</p>
        <pre>&lt;?php

require_once(CITY_PHP . 'database/PostgreSqlDatabaseHandle.php');
require_once(EXAMPLE2_PHP . 'database/IDatabaseApi.php');

class DatabaseApi extends PostgreSqlDatabaseHandle implements IDatabaseApi {
    public function __construct() {
        parent::__construct(PGSQL_DATABASE_CONNECTION_STRING);
    }

    public function install() {
        $query = sprintf('CREATE TABLE %s (
            word_id SERIAL PRIMARY KEY,
            word VARCHAR(64))',
            self::TABLE_WORDS);

        $this-&gt;writeQuery($query);
    }

    public function selectWords() {
        $query = sprintf('SELECT word_id, word FROM %s', self::TABLE_WORDS);
        return $this-&gt;readQuery($query);
    }

    public function insertWords(array $words) {
        foreach($words as $word) {
            $query = sprintf("INSERT INTO %s
                (word_id, word) VALUES(DEFAULT, '%s')",
                self::TABLE_WORDS,
                $this-&gt;escapeString($word));

            $this-&gt;writeQuery($query);
        }
    }
}

?&gt;</pre>
        <p>index.php:<p>
        <pre>&lt;?php

require_once('./constants.php');
require_once(EXAMPLE2_PHP . 'database/DatabaseApi.php');

$words = array('123',
    "'green'",
    '"dog"',
    '&&gt;&lt;\/"');

$databaseApi = new DatabaseApi();
$databaseApi-&gt;install();
$databaseApi-&gt;insertWords($words);

foreach($databaseApi-&gt;selectWords() as $row) {
    printf('%s=%s ', $row['word_id'], htmlspecialchars($row['word']));
}

?&gt;</pre>
        <p>And the output is the same as before:</p>
        <pre>1=123 2='green' 3="dog" 4=&&gt;&lt;\/"</pre>
        <p>Let's go over the above source code. constants.php defines the required CITY_PHP constant, an EXAMPLE2_PHP application directory constant and a database credential constant. Next is the IDatabaseApi interface; in the IDatabaseApi interface we list all the database table names as constants and we list all the public methods available for interacting with the database. The IDatabaseApi interface is useful because it gives us a quick overview of the entire database system. You should always use an interface with database table name constants and public database interaction methods when you use the database API architecture.</p>
        <p>Next is the DatabaseApi class. DatabaseApi extends PostgreSqlDatabaseHandle and implements the IDatabaseApi interface. It's important to realize that you can use any DatabaseHandle child class when you use this database API architecture; we just happened to pick PostgreSqlDatabaseHandle for this example. Note how we implement a constructor in the DatabaseApi class so that we can pass our database credentials up to the parent PostgreSqlDatabaseHandle constructor. It is beneficial to put the database credentials in the DatabaseApi constructor like this because it simplifies DatabaseApi object instantiation. Also note that this application was tested against PostgreSQL 7.4 which does not support inserting multiple rows per INSERT query; as a result the insertWords() method must execute an INSERT query for each word.</p>
        <p>The last file is index.php. In index.php we use a DatabaseApi object to interact with the database. If you compare this index.php to the index.php in the first example, you can see how the database API architecture helps to clean-up the codebase.</p>
        <p>Now let's do the second database API example. This database API example shows how to support multiple database vendors per application. You can use it to support any set of database vendors; in this example we will support both MySQL and PostgreSQL. In order to support multiple database vendors per application we use the abstract DatabaseAdapter class. DatabaseAdapter is a simple class. DatabaseAdapter wraps all the public DatabaseHandle methods using protected methods. DatabaseAdapter also has a constructor for setting its DatabaseHandle. For this example application we need to use seven files: constants.php, IDatabaseApi.php, DatabaseApi.php, MySqlDatabaseApi.php, PostgreSqlDatabaseApi.php, DatabaseApiFactory.php and index.php. Here is constants.php:</p>
        <pre>&lt;?php

define('CITY_PHP', '/somedir/cityphp/');
define('EXAMPLE3_PHP', '/somedir/example3php/');
define('DATABASE_VENDOR' ,'postgresql');

define('MYSQL_DATABASE_HOST', 'host');
define('MYSQL_DATABASE_USERNAME', 'username');
define('MYSQL_DATABASE_PASSWORD', 'password');
define('MYSQL_DATABASE_NAME', 'databaseName');

define('PGSQL_DATABASE_CONNECTION_STRING', 'dbname=myDatabaseName
    user=myUsername
    password=myPassword');

?&gt;</pre>
        <p>IDatabaseApi.php(exactly the same as the previous example):</p>
        <pre>&lt;?php

interface IDatabaseApi {
    const TABLE_WORDS = 'words';

    public function install();
    public function selectWords();
    public function insertWords(array $words);
}

?&gt;</pre>
        <p>DatabaseApi.php:</p>
        <pre>&lt;?php

require_once(CITY_PHP . 'database/DatabaseAdapter.php');
require_once(EXAMPLE3_PHP . 'database/IDatabaseApi.php');

abstract class DatabaseApi extends DatabaseAdapter implements IDatabaseApi {
    public function install() {
        $query = sprintf('CREATE TABLE %s (
            word_id %s,
            word VARCHAR(64))',
            self::TABLE_WORDS,
            $this-&gt;getWordIDType());

        $this-&gt;writeQuery($query);
    }

    public function selectWords() {
        $query = sprintf('SELECT word_id, word FROM %s', self::TABLE_WORDS);
        return $this-&gt;readQuery($query);
    }

    abstract protected function getWordIDType();
}

?&gt;</pre>
        <p>MySqlDatabaseApi.php:</p>
        <pre>&lt;?php

require_once(CITY_PHP . 'database/MySqlDatabaseHandle.php');
require_once(EXAMPLE3_PHP . 'database/DatabaseApi.php');

class MySqlDatabaseApi extends DatabaseApi {
    public function __construct(MySqlDatabaseHandle $databaseHandle) {
        parent::__construct($databaseHandle);
    }

    public function insertWords(array $words) {
        $query = sprintf('INSERT INTO %s
            (word_id, word) VALUES',
            self::TABLE_WORDS);

        foreach($words as $i =&gt; $word) {
            $query .= $i &gt; 0 ? ',' : '';
            $query .= sprintf('(NULL, "%s")',
                $this-&gt;escapeString($word));
        }

        $this-&gt;writeQuery($query);
    }

    protected function getWordIDType() {
        return 'TINYINT AUTO_INCREMENT NOT NULL PRIMARY KEY';
    }
}

?&gt;</pre>
        <p>PostgreSqlDatabaseApi.php:</p>
        <pre>&lt;?php

require_once(CITY_PHP . 'database/PostgreSqlDatabaseHandle.php');
require_once(EXAMPLE3_PHP . 'database/DatabaseApi.php');

class PostgreSqlDatabaseApi extends DatabaseApi {
    public function __construct(PostgreSqlDatabaseHandle $databaseHandle) {
        parent::__construct($databaseHandle);
    }

    public function insertWords(array $words) {
        foreach($words as $word) {
            $query = sprintf("INSERT INTO %s
                (word_id, word) VALUES(DEFAULT, '%s')",
                self::TABLE_WORDS,
                $this-&gt;escapeString($word));

            $this-&gt;writeQuery($query);
        }
    }

    protected function getWordIDType() {
        return 'SERIAL PRIMARY KEY';
    }
}

?&gt;</pre>
        <p>DatabaseApiFactory.php:</p>
        <pre>&lt;?php

require_once(CITY_PHP . 'database/MySqlDatabaseHandle.php');
require_once(CITY_PHP . 'database/PostgreSqlDatabaseHandle.php');
require_once(EXAMPLE3_PHP . 'database/MySqlDatabaseApi.php');
require_once(EXAMPLE3_PHP . 'database/PostgreSqlDatabaseApi.php');

class DatabaseApiFactory {
    public static function getDatabaseApi() {
        switch(DATABASE_VENDOR) {
            case 'postgresql':
                $databaseHandle = new PostgreSqlDatabaseHandle(PGSQL_DATABASE_CONNECTION_STRING);
                $databaseApi = new PostgreSqlDatabaseApi($databaseHandle);
                break;
            default:
                $databaseHandle = new MySqlDatabaseHandle(MYSQL_DATABASE_HOST,
                    MYSQL_DATABASE_USERNAME,
                    MYSQL_DATABASE_PASSWORD,
                    MYSQL_DATABASE_NAME);
                $databaseApi = new MySqlDatabaseApi($databaseHandle);
        }

        return $databaseApi;
    }
}

?&gt;</pre>
        <p>index.php:</p>
        <pre>&lt;?php

require_once('./constants.php');
require_once(EXAMPLE3_PHP . 'database/DatabaseApiFactory.php');

$words = array('123',
    "'green'",
    '"dog"',
    '&&gt;&lt;\/"');

$databaseApi = DatabaseApiFactory::getDatabaseApi();
$databaseApi-&gt;install();
$databaseApi-&gt;insertWords($words);

foreach($databaseApi-&gt;selectWords() as $row) {
    printf('%s=%s ', $row['word_id'], htmlspecialchars($row['word']));
}

?&gt;</pre>
        <p>The output is the same as the first two examples:</p>
        <pre>1=123 2='green' 3="dog" 4=&&gt;&lt;\/"</pre>
        <p>Let's review the above source code. constants.php has the required CITY_PHP constant and an EXAMPLE3_PHP application directory constant. There is a DATABASE_VENDOR constant that controls which database vendor our application uses. If DATABASE_VENDOR is set to 'postgresql' then PostgreSQL is used and any other value will use MySQL. Also in constants.php there are database credentials for both MySQL and PostgreSQL. The IDatabaseApi interface is the same as in the previous example.</p>
        <p>Next let's look at DatabaseApi, MySqlDatabaseApi and PostgreSqlDatabaseApi. When you use this database API architecture there is one abstract parent database API class. Then there is a class for each database vendor that extends the abstract parent database API class. The abstract parent database API class should extend DatabaseAdapter and implement your database API interface. The abstract parent database API class contains database logic that the different database vendors share. The database API child classes contain logic specific to the respective database vendor. In this case the abstract parent database API class is DatabaseApi and the database API child classes are MySqlDatabaseApi and PostgreSqlDatabaseApi. Note how we define a constructor in each database API child class that restricts the type of DatabaseHandle that can be passed in.</p>
        <p>DatabaseApiFactory has one public static method called getDatabaseApi(). getDatabaseApi() will return either a MySqlDatabaseApi object or a PostgreSqlDatabaseApi object depending on the DATABASE_VENDOR constant that is defined in constants.php. index.php is the same as in the previous database API architecture example except we are using a DatabaseApiFactory to get the database API object.</p>
        <p>This concludes the database system discussion.</p>
    </body>
</html>
